// crypto-fl: cryptography primitives and wrappers
// Copyright 2026 Dark Bio AG. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/// HKDF cryptography wrappers and parametrization.
///
/// https://datatracker.ietf.org/doc/html/rfc5869
library;

import 'dart:typed_data';

import 'src/generated/api/hkdf.dart' as ffi;

/// Derives a key from the secret, salt, and info using HKDF-SHA256, returning
/// a byte array that can be used as a cryptographic key.
///
/// Throws if [length] exceeds the maximum output length for SHA-256 HKDF, which
/// is 255 * 32 = 8160 bytes.
Uint8List key({
  required Uint8List secret,
  required Uint8List salt,
  required Uint8List info,
  int length = 32,
}) => ffi.hkdfKey(
  secret: secret,
  salt: salt,
  info: info,
  length: BigInt.from(length),
);

/// Generates a pseudorandom key for use with [expand] from an input secret
/// and an optional independent salt.
///
/// Only use this function if you need to reuse the extracted key with multiple
/// [expand] invocations and different context values. Most common scenarios,
/// including the generation of multiple keys, should use [key] instead.
Uint8List extract({required Uint8List secret, required Uint8List salt}) =>
    ffi.hkdfExtract(secret: secret, salt: salt);

/// Derives a key, using the given pseudorandom key and optional context info,
/// skipping the extraction step.
///
/// The [prk] should have been generated by [extract], or be a uniformly random
/// or pseudorandom cryptographically strong key. See RFC 5869, Section 3.3.
/// Most common scenarios will want to use [key] instead.
Uint8List expand({
  required Uint8List prk,
  required Uint8List info,
  int length = 32,
}) => ffi.hkdfExpand(prk: prk, info: info, length: BigInt.from(length));
