// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'xdsa.dart';
import 'xhpke.dart';

/// Creates a COSE_Sign1 signature with an embedded payload.
///
/// - `msg_to_embed`: The payload to embed and sign
/// - `msg_to_auth`: Additional authenticated data (external AAD)
/// - `signer`: The private key to sign with
/// - `domain`: Application-specific domain separator
Uint8List coseSign({
  required List<int> msgToEmbed,
  required List<int> msgToAuth,
  required XdsaSecretKey signer,
  required List<int> domain,
}) => RustLib.instance.api.crateApiCoseCoseSign(
  msgToEmbed: msgToEmbed,
  msgToAuth: msgToAuth,
  signer: signer,
  domain: domain,
);

/// Creates a COSE_Sign1 signature without an embedded payload (detached mode).
///
/// - `msg_to_auth`: The message to authenticate (external AAD)
/// - `signer`: The private key to sign with
/// - `domain`: Application-specific domain separator
Uint8List coseSignDetached({
  required List<int> msgToAuth,
  required XdsaSecretKey signer,
  required List<int> domain,
}) => RustLib.instance.api.crateApiCoseCoseSignDetached(
  msgToAuth: msgToAuth,
  signer: signer,
  domain: domain,
);

/// Verifies a COSE_Sign1 signature and returns the embedded payload.
///
/// - `msg_to_check`: The COSE_Sign1 structure to verify
/// - `msg_to_auth`: Additional authenticated data (external AAD)
/// - `verifier`: The public key to verify against
/// - `domain`: Application-specific domain separator
/// - `max_drift_secs`: Maximum allowed clock drift (None for no time check)
Uint8List coseVerify({
  required List<int> msgToCheck,
  required List<int> msgToAuth,
  required XdsaPublicKey verifier,
  required List<int> domain,
  BigInt? maxDriftSecs,
}) => RustLib.instance.api.crateApiCoseCoseVerify(
  msgToCheck: msgToCheck,
  msgToAuth: msgToAuth,
  verifier: verifier,
  domain: domain,
  maxDriftSecs: maxDriftSecs,
);

/// Verifies a COSE_Sign1 signature with a detached payload.
///
/// - `msg_to_check`: The COSE_Sign1 structure to verify
/// - `msg_to_auth`: The detached message to authenticate
/// - `verifier`: The public key to verify against
/// - `domain`: Application-specific domain separator
/// - `max_drift_secs`: Maximum allowed clock drift (None for no time check)
void coseVerifyDetached({
  required List<int> msgToCheck,
  required List<int> msgToAuth,
  required XdsaPublicKey verifier,
  required List<int> domain,
  BigInt? maxDriftSecs,
}) => RustLib.instance.api.crateApiCoseCoseVerifyDetached(
  msgToCheck: msgToCheck,
  msgToAuth: msgToAuth,
  verifier: verifier,
  domain: domain,
  maxDriftSecs: maxDriftSecs,
);

/// Extracts the signer's fingerprint from a COSE_Sign1 without verifying.
XdsaFingerprint coseSigner({required List<int> signature}) =>
    RustLib.instance.api.crateApiCoseCoseSigner(signature: signature);

/// Extracts the embedded payload from a COSE_Sign1 without verifying.
///
/// Warning: This does NOT verify the signature. The returned payload is
/// unauthenticated and should not be trusted until verified with `verify`.
Uint8List cosePeek({required List<int> signature}) =>
    RustLib.instance.api.crateApiCoseCosePeek(signature: signature);

/// Extracts the recipient's fingerprint from a COSE_Encrypt0 without decrypting.
XhpkeFingerprint coseRecipient({required List<int> ciphertext}) =>
    RustLib.instance.api.crateApiCoseCoseRecipient(ciphertext: ciphertext);

/// Encrypts an already-signed COSE_Sign1 to a recipient.
///
/// For most use cases, prefer `seal` which signs and encrypts in one step.
/// Use this only when re-encrypting a message (from `decrypt`) to a different
/// recipient without access to the original signer's key.
///
/// - `sign1`: The COSE_Sign1 structure (e.g., from `decrypt`)
/// - `msg_to_auth`: The same additional authenticated data used during sealing
/// - `recipient`: The xHPKE public key to encrypt to
/// - `domain`: Application domain for HPKE key derivation
Uint8List coseEncrypt({
  required List<int> sign1,
  required List<int> msgToAuth,
  required XhpkePublicKey recipient,
  required List<int> domain,
}) => RustLib.instance.api.crateApiCoseCoseEncrypt(
  sign1: sign1,
  msgToAuth: msgToAuth,
  recipient: recipient,
  domain: domain,
);

/// Decrypts a sealed message without verifying the signature.
///
/// This allows inspecting the signer before verification. Use `signer` to
/// extract the signer's fingerprint, then `verify` to verify.
///
/// - `msg_to_open`: The serialized COSE_Encrypt0 structure
/// - `msg_to_auth`: The same additional authenticated data used during sealing
/// - `recipient`: The xHPKE secret key to decrypt with
/// - `domain`: Application domain for HPKE key derivation
///
/// Returns the decrypted COSE_Sign1 structure (not yet verified).
Uint8List coseDecrypt({
  required List<int> msgToOpen,
  required List<int> msgToAuth,
  required XhpkeSecretKey recipient,
  required List<int> domain,
}) => RustLib.instance.api.crateApiCoseCoseDecrypt(
  msgToOpen: msgToOpen,
  msgToAuth: msgToAuth,
  recipient: recipient,
  domain: domain,
);

/// Signs a message then encrypts it to a recipient (sign-then-encrypt).
///
/// - `msg_to_seal`: The payload to sign and encrypt
/// - `msg_to_auth`: Additional authenticated data (external AAD)
/// - `signer`: The private key to sign with
/// - `recipient`: The public key to encrypt to
/// - `domain`: Application-specific domain separator
Uint8List coseSeal({
  required List<int> msgToSeal,
  required List<int> msgToAuth,
  required XdsaSecretKey signer,
  required XhpkePublicKey recipient,
  required List<int> domain,
}) => RustLib.instance.api.crateApiCoseCoseSeal(
  msgToSeal: msgToSeal,
  msgToAuth: msgToAuth,
  signer: signer,
  recipient: recipient,
  domain: domain,
);

/// Decrypts and verifies a sealed message.
///
/// - `msg_to_open`: The COSE structure to decrypt and verify
/// - `msg_to_auth`: Additional authenticated data (external AAD)
/// - `recipient`: The private key to decrypt with
/// - `sender`: The public key to verify the signature against
/// - `domain`: Application-specific domain separator
/// - `max_drift_secs`: Maximum allowed clock drift (None for no time check)
Uint8List coseOpen({
  required List<int> msgToOpen,
  required List<int> msgToAuth,
  required XhpkeSecretKey recipient,
  required XdsaPublicKey sender,
  required List<int> domain,
  BigInt? maxDriftSecs,
}) => RustLib.instance.api.crateApiCoseCoseOpen(
  msgToOpen: msgToOpen,
  msgToAuth: msgToAuth,
  recipient: recipient,
  sender: sender,
  domain: domain,
  maxDriftSecs: maxDriftSecs,
);
